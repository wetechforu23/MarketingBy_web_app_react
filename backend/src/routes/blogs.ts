import express, { Request, Response } from 'express';
import axios from 'axios';
import { BlogService } from '../services/blogService';

const router = express.Router();

// =====================================================
// Middleware to check authentication
// =====================================================
function requireAuth(req: Request, res: Response, next: Function) {
  if (!req.session || !req.session.userId) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  next();
}

// =====================================================
// Blog CRUD Endpoints
// =====================================================

/**
 * GET /api/blogs/:clientId
 * Get all blog posts for a client
 */
router.get('/:clientId', requireAuth, async (req: Request, res: Response) => {
  try {
    const clientId = parseInt(req.params.clientId);
    const { status, limit, offset, search } = req.query;
    
    const result = await BlogService.getBlogPostsByClient(clientId, {
      status: status as string,
      limit: limit ? parseInt(limit as string) : undefined,
      offset: offset ? parseInt(offset as string) : undefined,
      search: search as string
    });
    
    res.json({
      success: true,
      posts: result.posts,
      total: result.total
    });
  } catch (error: any) {
    console.error('❌ Error fetching blog posts:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/blogs/post/:postId
 * Get a single blog post by ID
 */
router.get('/post/:postId', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const post = await BlogService.getBlogPost(postId);
    
    if (!post) {
      return res.status(404).json({ error: 'Blog post not found' });
    }
    
    res.json({ success: true, post });
  } catch (error: any) {
    console.error('❌ Error fetching blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs
 * Create a new blog post (manual entry)
 */
router.post('/', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id, title, content, excerpt, featured_image_url, meta_title, meta_description, meta_keywords, categories, tags } = req.body;
    
    if (!client_id || !title || !content) {
      return res.status(400).json({ error: 'Missing required fields: client_id, title, content' });
    }
    
    const post = await BlogService.createBlogPost({
      client_id,
      title,
      slug: '', // Will be auto-generated by BlogService
      content,
      excerpt,
      featured_image_url,
      meta_title,
      meta_description,
      meta_keywords,
      categories,
      tags,
      author_id: req.session.userId,
      author_name: req.session.username || 'Admin',
      generated_by: 'manual',
      status: 'draft'
    });
    
    res.json({ success: true, post });
  } catch (error: any) {
    console.error('❌ Error creating blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * PUT /api/blogs/:postId
 * Update a blog post
 */
router.put('/:postId', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const updates = req.body;
    
    const post = await BlogService.updateBlogPost(postId, updates);
    
    res.json({ success: true, post });
  } catch (error: any) {
    console.error('❌ Error updating blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * DELETE /api/blogs/:postId
 * Delete a blog post
 */
router.delete('/:postId', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    await BlogService.deleteBlogPost(postId);
    
    res.json({ success: true, message: 'Blog post deleted' });
  } catch (error: any) {
    console.error('❌ Error deleting blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// AI Generation Endpoint
// =====================================================

/**
 * POST /api/blogs/generate-ai
 * Generate blog post using AI
 */
router.post('/generate-ai', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id, prompt, tone, target_word_count } = req.body;
    
    if (!client_id || !prompt) {
      return res.status(400).json({ error: 'Missing required fields: client_id, prompt' });
    }
    
    const post = await BlogService.generateBlogWithAI({
      client_id,
      prompt,
      tone,
      target_word_count,
      author_id: req.session.userId!,
      author_name: req.session.username || 'Admin'
    });
    
    res.json({ success: true, post });
  } catch (error: any) {
    console.error('❌ Error generating blog with AI:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/generate-image
 * Generate/search for blog images using Unsplash API
 */
router.post('/generate-image', requireAuth, async (req: Request, res: Response) => {
  try {
    const { query, orientation = 'landscape' } = req.body;
    
    if (!query) {
      return res.status(400).json({ error: 'Missing required field: query' });
    }
    
    // Use Unsplash API (no API key needed for low volume)
    // For production, get free API key from: https://unsplash.com/developers
    const axios = require('axios');
    
    // Search Unsplash for relevant images
    // Using demo access key - for production, get your own free key from: https://unsplash.com/developers
    const UNSPLASH_ACCESS_KEY = process.env.UNSPLASH_ACCESS_KEY || 'your-demo-key-here';
    
    const unsplashResponse = await axios.get('https://api.unsplash.com/search/photos', {
      params: {
        query: query,
        orientation: orientation,
        per_page: 6,
        order_by: 'relevant'
      },
      headers: {
        'Authorization': `Client-ID ${UNSPLASH_ACCESS_KEY}`,
        'Accept-Version': 'v1'
      }
    });
    
    const images = unsplashResponse.data.results.map((photo: any) => ({
      id: photo.id,
      url: photo.urls.regular, // 1080px wide
      url_small: photo.urls.small, // 400px wide (for preview)
      url_full: photo.urls.full, // Full resolution
      description: photo.description || photo.alt_description || query,
      photographer: photo.user.name,
      photographer_username: photo.user.username,
      photographer_url: photo.user.links.html,
      download_location: photo.links.download_location, // Required for tracking
      width: photo.width,
      height: photo.height,
      color: photo.color
    }));
    
    res.json({
      success: true,
      images: images,
      query: query
    });
    
  } catch (error: any) {
    console.error('❌ Error generating/searching images:', error);
    
    // Fallback: Return stock/placeholder suggestions with alternative placeholder service
    const query = req.body.query || 'Blog Image';
    res.json({
      success: true,
      images: [
        {
          id: 'placeholder-1',
          url: `https://placehold.co/1200x628/4682B4/ffffff/png?text=${encodeURIComponent(query)}`,
          url_small: `https://placehold.co/400x210/4682B4/ffffff/png?text=Blog+Image`,
          description: 'Placeholder - Get free Unsplash API key for real images',
          photographer: 'Placeholder',
          photographer_url: 'https://unsplash.com/developers',
          width: 1200,
          height: 628
        },
        {
          id: 'placeholder-2',
          url: `https://placehold.co/1200x628/2E86AB/ffffff/png?text=${encodeURIComponent('Healthcare Marketing')}`,
          url_small: `https://placehold.co/400x210/2E86AB/ffffff/png?text=Healthcare`,
          description: 'Healthcare placeholder - Add Unsplash key for real photos',
          photographer: 'Placeholder',
          photographer_url: 'https://unsplash.com/developers',
          width: 1200,
          height: 628
        }
      ],
      query: query,
      note: 'Unsplash API key required. Get free key at: https://unsplash.com/developers'
    });
  }
});

// =====================================================
// Approval Workflow Endpoints
// =====================================================

/**
 * POST /api/blogs/:postId/send-approval
 * Send blog post for client approval
 */
router.post('/:postId/send-approval', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const token = await BlogService.sendForApproval(postId, true);
    
    const approvalUrl = `${process.env.FRONTEND_URL}/blog/approve/${token}`;
    
    res.json({
      success: true,
      message: 'Blog sent for approval',
      approval_url: approvalUrl,
      token
    });
  } catch (error: any) {
    console.error('❌ Error sending blog for approval:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/blogs/approve/:token
 * Verify approval token and get blog post (for secure link approval)
 */
router.get('/approve/:token', async (req: Request, res: Response) => {
  try {
    const token = req.params.token;
    const post = await BlogService.verifyApprovalToken(token);
    
    if (!post) {
      return res.status(404).json({ error: 'Invalid or expired approval token' });
    }
    
    res.json({ success: true, post });
  } catch (error: any) {
    console.error('❌ Error verifying approval token:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/:postId/approve
 * Approve a blog post
 */
router.post('/:postId/approve', async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const { feedback, access_method, token } = req.body;
    
    // If using secure link, verify token first
    if (access_method === 'secure_link' && token) {
      const post = await BlogService.verifyApprovalToken(token);
      if (!post || post.id !== postId) {
        return res.status(400).json({ error: 'Invalid approval token' });
      }
    }
    
    await BlogService.approveBlogPost({
      post_id: postId,
      approved_by: req.session?.userId,
      approver_email: req.body.approver_email,
      approver_name: req.body.approver_name,
      feedback,
      access_method: access_method || 'portal_login',
      ip_address: req.ip,
      user_agent: req.headers['user-agent']
    });
    
    res.json({ success: true, message: 'Blog post approved' });
  } catch (error: any) {
    console.error('❌ Error approving blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/:postId/reject
 * Reject a blog post
 */
router.post('/:postId/reject', async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const { feedback, access_method, token } = req.body;
    
    if (!feedback) {
      return res.status(400).json({ error: 'Feedback is required when rejecting a blog post' });
    }
    
    // If using secure link, verify token first
    if (access_method === 'secure_link' && token) {
      const post = await BlogService.verifyApprovalToken(token);
      if (!post || post.id !== postId) {
        return res.status(400).json({ error: 'Invalid approval token' });
      }
    }
    
    await BlogService.rejectBlogPost({
      post_id: postId,
      approved_by: req.session?.userId,
      approver_email: req.body.approver_email,
      approver_name: req.body.approver_name,
      feedback,
      access_method: access_method || 'portal_login',
      ip_address: req.ip,
      user_agent: req.headers['user-agent']
    });
    
    res.json({ success: true, message: 'Blog post rejected' });
  } catch (error: any) {
    console.error('❌ Error rejecting blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// Publishing Endpoints
// =====================================================

/**
 * POST /api/blogs/:postId/publish
 * Publish blog post to WordPress
 */
router.post('/:postId/publish', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const url = await BlogService.publishToWordPress(postId);
    
    res.json({
      success: true,
      message: 'Blog post published to WordPress',
      url
    });
  } catch (error: any) {
    console.error('❌ Error publishing blog post:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// Analytics Endpoints
// =====================================================

/**
 * POST /api/blogs/track/:postId/view
 * Track blog post view (public endpoint)
 */
router.post('/track/:postId/view', async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const analytics = {
      client_id: req.body.client_id,
      visitor_fingerprint: req.body.visitor_fingerprint,
      session_id: req.body.session_id,
      ip_address: req.ip,
      country: req.body.country,
      city: req.body.city,
      page_url: req.body.page_url,
      referrer_url: req.body.referrer_url || req.headers.referer,
      utm_source: req.body.utm_source,
      utm_medium: req.body.utm_medium,
      utm_campaign: req.body.utm_campaign,
      utm_term: req.body.utm_term,
      utm_content: req.body.utm_content,
      device_type: req.body.device_type,
      browser: req.body.browser,
      os: req.body.os
    };
    
    await BlogService.trackView(postId, analytics);
    
    res.json({ success: true });
  } catch (error: any) {
    console.error('❌ Error tracking blog view:', error);
    res.status(200).json({ success: false }); // Don't fail the page load
  }
});

/**
 * POST /api/blogs/track/:postId/time
 * Update time spent on blog post
 */
router.post('/track/:postId/time', async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const { session_id, time_on_page, scroll_depth } = req.body;
    
    // Update the analytics record
    await BlogService.updateAnalytics(postId, session_id, {
      time_on_page,
      scroll_depth
    });
    
    res.json({ success: true });
  } catch (error: any) {
    console.error('❌ Error updating blog time tracking:', error);
    res.status(200).json({ success: false });
  }
});

/**
 * GET /api/blogs/:postId/analytics
 * Get analytics for a blog post
 */
router.get('/:postId/analytics', requireAuth, async (req: Request, res: Response) => {
  try {
    const postId = parseInt(req.params.postId);
    const analytics = await BlogService.getAnalytics(postId);
    
    res.json({ success: true, analytics });
  } catch (error: any) {
    console.error('❌ Error fetching blog analytics:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// Category Management Endpoints
// =====================================================

/**
 * GET /api/blogs/categories/:clientId
 * Get all categories for a client
 */
router.get('/categories/:clientId', requireAuth, async (req: Request, res: Response) => {
  try {
    const clientId = parseInt(req.params.clientId);
    const categories = await BlogService.getCategories(clientId);
    
    res.json({ success: true, categories });
  } catch (error: any) {
    console.error('❌ Error fetching categories:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/categories
 * Create a new category
 */
router.post('/categories', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id, name, description, parent_id } = req.body;
    
    if (!client_id || !name) {
      return res.status(400).json({ error: 'Missing required fields: client_id, name' });
    }
    
    const category = await BlogService.createCategory({
      client_id,
      name,
      description,
      parent_id
    });
    
    res.json({ success: true, category });
  } catch (error: any) {
    console.error('❌ Error creating category:', error);
    res.status(500).json({ error: error.message });
  }
});

// =====================================================
// Blog Settings Endpoints
// =====================================================

/**
 * POST /api/blogs/settings/wordpress
 * Save WordPress credentials for a client
 */
router.post('/settings/wordpress', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id, site_url, username, app_password } = req.body;
    
    if (!client_id || !site_url || !username || !app_password) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Import pool
    const pool = require('../config/database').default;
    const crypto = require('crypto');
    
    // Get encryption key
    const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-encryption-key-change-this';
    const key = Buffer.from(ENCRYPTION_KEY.padEnd(32, '0').substring(0, 32));
    
    // Function to encrypt
    const encrypt = (text: string): string => {
      const iv = crypto.randomBytes(16);
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
      let encrypted = cipher.update(text, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return iv.toString('hex') + ':' + encrypted;
    };
    
    // Save or update credentials (using old schema without client_id)
    // We'll use service name like 'wordpress_client_123'
    const serviceName = `wordpress_client_${client_id}`;
    
    // Save site_url
    await pool.query(
      `INSERT INTO encrypted_credentials (service, key_name, encrypted_value, description)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (service, key_name) 
       DO UPDATE SET encrypted_value = EXCLUDED.encrypted_value, updated_at = CURRENT_TIMESTAMP`,
      [serviceName, 'site_url', encrypt(site_url), `WordPress site URL for client ${client_id}`]
    );
    
    // Save username
    await pool.query(
      `INSERT INTO encrypted_credentials (service, key_name, encrypted_value, description)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (service, key_name) 
       DO UPDATE SET encrypted_value = EXCLUDED.encrypted_value, updated_at = CURRENT_TIMESTAMP`,
      [serviceName, 'username', encrypt(username), `WordPress username for client ${client_id}`]
    );
    
    // Save app_password
    await pool.query(
      `INSERT INTO encrypted_credentials (service, key_name, encrypted_value, description)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (service, key_name) 
       DO UPDATE SET encrypted_value = EXCLUDED.encrypted_value, updated_at = CURRENT_TIMESTAMP`,
      [serviceName, 'app_password', encrypt(app_password), `WordPress app password for client ${client_id}`]
    );
    
    console.log(`✅ WordPress credentials saved for client ${client_id}`);
    
    res.json({ 
      success: true, 
      message: 'WordPress credentials saved successfully' 
    });
  } catch (error: any) {
    console.error('❌ Error saving WordPress credentials:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/settings/ai
 * Save Google AI credentials for a client
 */
router.post('/settings/ai', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id, api_key, max_credits } = req.body;
    
    if (!client_id || !api_key) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Import pool
    const pool = require('../config/database').default;
    const crypto = require('crypto');
    
    // Get encryption key
    const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-encryption-key-change-this';
    const key = Buffer.from(ENCRYPTION_KEY.padEnd(32, '0').substring(0, 32));
    
    // Function to encrypt
    const encrypt = (text: string): string => {
      const iv = crypto.randomBytes(16);
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
      let encrypted = cipher.update(text, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return iv.toString('hex') + ':' + encrypted;
    };
    
    // Save or update credentials
    const serviceName = `google_ai_client_${client_id}`;
    
    // Save API key
    await pool.query(
      `INSERT INTO encrypted_credentials (service, key_name, encrypted_value, description)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (service, key_name) 
       DO UPDATE SET encrypted_value = EXCLUDED.encrypted_value, updated_at = CURRENT_TIMESTAMP`,
      [serviceName, 'api_key', encrypt(api_key), `Google AI API key for client ${client_id}`]
    );
    
    // Save max credits (not encrypted, just metadata)
    await pool.query(
      `INSERT INTO encrypted_credentials (service, key_name, encrypted_value, description)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (service, key_name) 
       DO UPDATE SET encrypted_value = EXCLUDED.encrypted_value, updated_at = CURRENT_TIMESTAMP`,
      [serviceName, 'max_credits', String(max_credits || 100000), `Monthly token limit for client ${client_id}`]
    );
    
    console.log(`✅ Google AI credentials saved for client ${client_id}`);
    
    res.json({ 
      success: true, 
      message: 'Google AI credentials saved successfully' 
    });
  } catch (error: any) {
    console.error('❌ Error saving Google AI credentials:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/blogs/settings/:clientId
 * Get blog settings for a client (without sensitive data)
 */
router.get('/settings/:clientId', requireAuth, async (req: Request, res: Response) => {
  try {
    const clientId = parseInt(req.params.clientId);
    const pool = require('../config/database').default;
    
    // Get WordPress settings (without passwords)
    const wpService = `wordpress_client_${clientId}`;
    const wpResult = await pool.query(
      `SELECT key_name, description 
       FROM encrypted_credentials 
       WHERE service = $1 AND key_name IN ('site_url', 'username')`,
      [wpService]
    );
    
    // Get AI settings
    const aiService = `google_ai_client_${clientId}`;
    const aiResult = await pool.query(
      `SELECT key_name, encrypted_value 
       FROM encrypted_credentials 
       WHERE service = $1 AND key_name IN ('api_key', 'max_credits')`,
      [aiService]
    );
    
    const settings: any = {
      wordpress: {
        configured: wpResult.rows.length >= 2,
        site_url_set: wpResult.rows.some(r => r.key_name === 'site_url'),
        username_set: wpResult.rows.some(r => r.key_name === 'username')
      },
      ai: {
        configured: aiResult.rows.some(r => r.key_name === 'api_key'),
        max_credits: aiResult.rows.find(r => r.key_name === 'max_credits')?.encrypted_value || '100000'
      }
    };
    
    res.json({ success: true, settings });
  } catch (error: any) {
    console.error('❌ Error fetching blog settings:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/blogs/settings/test-wordpress
 * Test WordPress connection
 */
router.post('/settings/test-wordpress', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id } = req.body;
    
    if (!client_id) {
      return res.status(400).json({ error: 'Client ID required' });
    }
    
    const pool = require('../config/database').default;
    const crypto = require('crypto');
    const axios = require('axios');
    
    // Get encryption key
    const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-encryption-key-change-this';
    const key = Buffer.from(ENCRYPTION_KEY.padEnd(32, '0').substring(0, 32));
    
    // Decrypt function
    const decrypt = (encrypted: string): string => {
      const parts = encrypted.split(':');
      const iv = Buffer.from(parts[0], 'hex');
      const encryptedText = parts[1];
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
      let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return decrypted;
    };
    
    // Get WordPress credentials
    const serviceName = `wordpress_client_${client_id}`;
    const wpResult = await pool.query(
      `SELECT key_name, encrypted_value 
       FROM encrypted_credentials 
       WHERE service = $1 AND key_name IN ('site_url', 'username', 'app_password')`,
      [serviceName]
    );
    
    if (wpResult.rows.length < 3) {
      return res.status(400).json({ error: 'WordPress credentials not configured' });
    }
    
    const creds: any = {};
    wpResult.rows.forEach((row: any) => {
      creds[row.key_name] = decrypt(row.encrypted_value);
    });
    
    const siteUrl = creds.site_url.replace(/\/$/, '');
    const authString = Buffer.from(`${creds.username}:${creds.app_password}`).toString('base64');
    
    // Test WordPress REST API
    const testResponse = await axios.get(`${siteUrl}/wp-json/wp/v2/posts?per_page=1`, {
      headers: {
        'Authorization': `Basic ${authString}`
      },
      timeout: 10000
    });
    
    if (testResponse.status === 200) {
      res.json({ 
        success: true, 
        message: '✅ WordPress connection successful!',
        details: {
          site_url: siteUrl,
          api_version: 'v2',
          authenticated: true
        }
      });
    } else {
      res.status(400).json({ error: 'WordPress API returned unexpected status' });
    }
    
  } catch (error: any) {
    console.error('❌ Error testing WordPress connection:', error);
    res.status(500).json({ 
      error: error.response?.data?.message || error.message || 'Failed to connect to WordPress'
    });
  }
});

/**
 * POST /api/blogs/settings/test-ai
 * Test Google AI API key
 */
router.post('/settings/test-ai', requireAuth, async (req: Request, res: Response) => {
  try {
    const { client_id } = req.body;
    
    if (!client_id) {
      return res.status(400).json({ error: 'Client ID required' });
    }
    
    const pool = require('../config/database').default;
    const crypto = require('crypto');
    const axios = require('axios');
    
    // Get encryption key
    const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-encryption-key-change-this';
    const key = Buffer.from(ENCRYPTION_KEY.padEnd(32, '0').substring(0, 32));
    
    // Decrypt function
    const decrypt = (encrypted: string): string => {
      const parts = encrypted.split(':');
      const iv = Buffer.from(parts[0], 'hex');
      const encryptedText = parts[1];
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
      let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return decrypted;
    };
    
    // Get AI credentials
    const serviceName = `google_ai_client_${client_id}`;
    const aiResult = await pool.query(
      `SELECT key_name, encrypted_value 
       FROM encrypted_credentials 
       WHERE service = $1 AND key_name = 'api_key'`,
      [serviceName]
    );
    
    if (aiResult.rows.length === 0) {
      return res.status(400).json({ error: 'Google AI API key not configured' });
    }
    
    const apiKey = decrypt(aiResult.rows[0].encrypted_value);
    
    // Test Google AI API with a simple request (gemini-2.5-flash - newer, faster, better)
    const testResponse = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
      {
        contents: [{
          parts: [{
            text: 'Say "Hello" in one word.'
          }]
        }]
      },
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 10000
      }
    );
    
    if (testResponse.data && testResponse.data.candidates) {
      res.json({ 
        success: true, 
        message: '✅ Google AI API key is valid and working with Gemini 2.5!',
        details: {
          model: 'gemini-2.5-flash',
          api_version: 'v1beta',
          test_response: testResponse.data.candidates[0]?.content?.parts[0]?.text || 'OK'
        }
      });
    } else {
      res.status(400).json({ error: 'Google AI API returned unexpected response' });
    }
    
  } catch (error: any) {
    console.error('❌ Error testing Google AI API:', error);
    res.status(500).json({ 
      error: error.response?.data?.error?.message || error.message || 'Failed to connect to Google AI API'
    });
  }
});

/**
 * POST /api/blogs/track-unsplash-download
 * Track Unsplash image download (REQUIRED for API compliance)
 */
router.post('/track-unsplash-download', async (req: Request, res: Response) => {
  try {
    const { download_location } = req.body;
    
    if (!download_location) {
      return res.status(400).json({ 
        success: false, 
        message: 'download_location is required' 
      });
    }

    const UNSPLASH_ACCESS_KEY = process.env.UNSPLASH_ACCESS_KEY || 'BNJr2AVHw1l52uw5zcxp3xpvuzPfEi-l5gMFjYAL4Sw';

    // Trigger Unsplash download tracking (required by API terms)
    await axios.get(download_location, {
      headers: {
        'Authorization': `Client-ID ${UNSPLASH_ACCESS_KEY}`
      }
    });

    console.log('✅ Unsplash download tracked:', download_location);
    res.json({ success: true });
  } catch (error: any) {
    console.error('⚠️ Error tracking Unsplash download:', error.response?.data || error.message);
    // Don't fail the request if tracking fails
    res.json({ success: true, warning: 'Download tracking failed' });
  }
});

export default router;

